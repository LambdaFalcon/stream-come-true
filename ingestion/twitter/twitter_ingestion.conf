input {
  twitter {
    id => "tweets_stream"
    consumer_key => "${CONSUMER_KEY}"
    consumer_secret => "${CONSUMER_SECRET}"
    oauth_token => "${OAUTH_TOKEN}"
    oauth_token_secret => "${OAUTH_TOKEN_SECRET}"
    keywords => ["android", "apple"]
    full_tweet => true
    ignore_retweets => true
    languages => ["en"]
  }
}

filter {

    # Add domain field to differentiate between multiple sources
    mutate {
        add_field => {"tweet_id" => "%{[id]}"}
        add_field => { "domain" => "android" }    
    }

    # Change domain according the keywords
    if [text] =~ /(?i)apple/ {
        mutate {
        update => {"domain" => "apple"}  
        }
    } 

    # Parsing date coming from this format Sat May 04 13:32:28 +0000 2019
    date {
        match => ["created_at", "EEE MMM dd HH:mm:ss Z yyyy"]
        target => "created_at"
    }

    if [user] {
        mutate {
            add_field => {
                "user_id" => "%{[user][id]}"
                "screen_name" => "%{[user][screen_name]}"
                "followers_count" => "%{[user][followers_count]}"
            }
        }
    }

    if [extended_tweet][full_text] {
        ruby {
          code => "event.set('hashtags', event.get('[extended_tweet][full_text]').scan(/\#[a-z]*/i))"
        }
    } 

    else {
        ruby {
          code => "event.set('hashtags', event.get('text').scan(/\#[a-z]*/i))"
        }   
  }

    prune {
        whitelist_names => [ "^tweet_id$", "^domain$", "^user_id$", "followers_count", "^screen_name$",
        "^text$", "^hashtags$", "coordinates", "^created_at$", "@timestamp" ]
    }

}

output {
    elasticsearch {
        hosts => ["rhea1.inf.usi.ch:9200"]
        index => "tweets"
        document_type => "tweet"
        template => "twitter_template.json"
        template_name => "tweets"
    }
}
